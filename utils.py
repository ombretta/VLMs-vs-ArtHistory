import os.path
import json
import numpy as np
import pandas as pd

import argparse

def parse_args():
    parser = argparse.ArgumentParser(description="Argument parser for image processing script")

    # Adding arguments
    parser.add_argument("--mode")
    parser.add_argument("--host")
    parser.add_argument("--port")
    parser.add_argument('--dataset_name', type=str, default='ArTest', help='Name of the dataset')
    parser.add_argument('--image_folder_path', type=str, default="datasets/ArTest/", help='Path to the folder containing images')
    parser.add_argument('--annotation_file', type=str, default="datasets/ArTest/ArTest.csv", help='Path to the annotation file')
    parser.add_argument('--features_dir', type=str, default="datasets/ArTest/ArTest_features/", help='Where to save the extracted features')
    parser.add_argument('--results_dir', type=str, default=None, help='Where to find the results.')
    parser.add_argument('--attribute', type=str, default="style", help='Name of the attribute to predict (e.g., style, genre, content,...)')
    parser.add_argument('--prompt', type=str, default='the art style of the painting is ')
    parser.add_argument('--n', type=int, default=-1, help='Number of images')
    parser.add_argument('--image_model', type=str, default="ViT-B/32")
    parser.add_argument('--text_model', type=str, default="anas-awadalla/mpt-1b-redpajama-200b", help='LLM used to analyze the prompt and generate the text.')
    parser.add_argument('--save_features', default=False, action='store_true', help="If true, save the CLIP features")
    parser.add_argument('--year_precision', type=int, default=100, help='Used in the zero-shot evaluation of the year predictions. Precision (10: decade, 100: century)')
    parser.add_argument('--plot_conf_matrix', default=True, type=bool, help='Whether to plot the confusion matrix.')
    parser.add_argument('--path_example_image1', type=str, default='Cubism_Picasso_Avignon_1907.jpg', help="Path to image to be used as example to the VLMs")
    parser.add_argument('--path_example_image2', type=str, default='Realism_David_Marat_1793.jpg', help="Path to image to be used as example to the VLMs")
    parser.add_argument('--max_new_tokens', type=int, default=200, help='Max new tokens generated by LLaVa and OpenFlamingo.')

    # Parsing arguments
    args = parser.parse_args()

    return args


def save_args_to_file(args, filepath):
    with open(filepath, 'w') as f:
        json.dump(vars(args), f, indent=4)


def get_style_order(dataset_name):

    """ Returns the art styles in a specific dataset sorted chronologically."""

    styles_order = {

        "WikiArt": [
            'Early_Renaissance', 'Northern_Renaissance', 'High_Renaissance', 'Mannerism_Late_Renaissance',
            'Baroque', 'Rococo', 'Romanticism', 'Ukiyo_e', 'Realism', "Impressionism", "Pointillism",
            "Post_Impressionism", "Symbolism", "Art_Nouveau_Modern", "Fauvism", 'Analytical_Cubism', "Cubism",
            "Synthetic_Cubism", "Expressionism", 'Naive_Art_Primitivism', "Abstract_Expressionism", "Action_painting",
            "Color_Field_Painting", "New_Realism", 'Pop_Art', 'Minimalism', 'Contemporary_Realism'
        ],

        "JenAesthetics": [
            "Renaissance", "Mannerism", "Baroque", "Classicism", "Rococo", "Romanticism", "Realism", "Impressionism",
            "Post_Impressionism", "Symbolism", "Expressionism"
        ],

        "ArTest": ['Early Renaissance', 'High Renaissance', 'Mannerism Late Renaissance', 'Northern Renaissance',
                   'Baroque', 'Rococo', 'Neo Classicism', 'Romanticism', 'Realism', 'Ukiyo-E', 'Impressionism',
                   'Post Impressionism', 'Symbolism', 'Art Nouveau', 'Fauvism', 'Cubism', "Analytical Cubism",
                   "Synthetic Cubism", 'Expressionism', 'Naive Art Primitivism', 'Surrealism', 'Abstract Expressionism',
                   'Color Field Painting', 'Minimalism', 'Pop Art',
        ]


    }

    if dataset_name not in styles_order:
        print("Invalid dataset name")
        return None

    return styles_order[dataset_name]


def create_confusion_matrix(y_true, y_pred, true_labels=None, pred_labels=None):
    """
    Creates a confusion matrix.

    Parameters:
    - y_true: List or array of ground truth class labels.
    - y_pred: List or array of predicted class labels.
    - true_labels: List of possible true class labels. If None, it will be inferred from y_true.
    - pred_labels: List of possible predicted class labels. If None, it will be inferred from y_pred.

    Returns:
    - cm_df: DataFrame representing the confusion matrix.
    """
    if true_labels is None:
        true_labels = np.unique(y_true)
    if pred_labels is None:
        pred_labels = np.unique(y_pred)

    # Initialize the confusion matrix with zeros
    cm = pd.DataFrame(0, index=true_labels, columns=pred_labels)

    # Populate the confusion matrix
    for t, p in zip(y_true, y_pred):
        if t in true_labels and p in pred_labels:
            cm.at[t, p] += 1

    return cm